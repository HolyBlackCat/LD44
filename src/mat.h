// mat.h
// Vector and matrix math
// Version 3.0.0 dev
// Autogenerated, don't touch.

#include <algorithm>
#include <cstddef>
#include <cstdint>
#include <type_traits>

namespace Math
{
    inline namespace Vector // Declarations and aliases
    {
        template <int D, typename T> struct vec;
        template <int W, int H, typename T> using mat = vec<W, vec<H, T>>;
        template <typename T> using vec2 = vec<2,T>; template <typename T> using vec3 = vec<3,T>; template <typename T> using vec4 = vec<4,T>;
        template <typename T> using mat2x2 = mat<2,2,T>; template <typename T> using mat3x2 = mat<3,2,T>; template <typename T> using mat4x2 = mat<4,2,T>;
        template <typename T> using mat2x3 = mat<2,3,T>; template <typename T> using mat3x3 = mat<3,3,T>; template <typename T> using mat4x3 = mat<4,3,T>;
        template <typename T> using mat2x4 = mat<2,4,T>; template <typename T> using mat3x4 = mat<3,4,T>; template <typename T> using mat4x4 = mat<4,4,T>;
        template <typename T> using mat2 = mat2x2<T>; template <typename T> using mat3 = mat3x3<T>; template <typename T> using mat4 = mat4x4<T>;
        
        template <int D> using bvec = vec<D,bool>;
        template <int W, int H> using bmat = mat<W,H,bool>;
        using bvec2 = vec<2,bool>; using bvec3 = vec<3,bool>; using bvec4 = vec<4,bool>;
        using bmat2x2 = mat<2,2,bool>; using bmat3x2 = mat<3,2,bool>; using bmat4x2 = mat<4,2,bool>;
        using bmat2x3 = mat<2,3,bool>; using bmat3x3 = mat<3,3,bool>; using bmat4x3 = mat<4,3,bool>;
        using bmat2x4 = mat<2,4,bool>; using bmat3x4 = mat<3,4,bool>; using bmat4x4 = mat<4,4,bool>;
        using bmat2 = bmat2x2; using bmat3 = bmat3x3; using bmat4 = bmat4x4;
        
        template <int D> using cvec = vec<D,char>;
        template <int W, int H> using cmat = mat<W,H,char>;
        using cvec2 = vec<2,char>; using cvec3 = vec<3,char>; using cvec4 = vec<4,char>;
        using cmat2x2 = mat<2,2,char>; using cmat3x2 = mat<3,2,char>; using cmat4x2 = mat<4,2,char>;
        using cmat2x3 = mat<2,3,char>; using cmat3x3 = mat<3,3,char>; using cmat4x3 = mat<4,3,char>;
        using cmat2x4 = mat<2,4,char>; using cmat3x4 = mat<3,4,char>; using cmat4x4 = mat<4,4,char>;
        using cmat2 = cmat2x2; using cmat3 = cmat3x3; using cmat4 = cmat4x4;
        
        template <int D> using ucvec = vec<D,unsigned char>;
        template <int W, int H> using ucmat = mat<W,H,unsigned char>;
        using ucvec2 = vec<2,unsigned char>; using ucvec3 = vec<3,unsigned char>; using ucvec4 = vec<4,unsigned char>;
        using ucmat2x2 = mat<2,2,unsigned char>; using ucmat3x2 = mat<3,2,unsigned char>; using ucmat4x2 = mat<4,2,unsigned char>;
        using ucmat2x3 = mat<2,3,unsigned char>; using ucmat3x3 = mat<3,3,unsigned char>; using ucmat4x3 = mat<4,3,unsigned char>;
        using ucmat2x4 = mat<2,4,unsigned char>; using ucmat3x4 = mat<3,4,unsigned char>; using ucmat4x4 = mat<4,4,unsigned char>;
        using ucmat2 = ucmat2x2; using ucmat3 = ucmat3x3; using ucmat4 = ucmat4x4;
        
        template <int D> using scvec = vec<D,signed char>;
        template <int W, int H> using scmat = mat<W,H,signed char>;
        using scvec2 = vec<2,signed char>; using scvec3 = vec<3,signed char>; using scvec4 = vec<4,signed char>;
        using scmat2x2 = mat<2,2,signed char>; using scmat3x2 = mat<3,2,signed char>; using scmat4x2 = mat<4,2,signed char>;
        using scmat2x3 = mat<2,3,signed char>; using scmat3x3 = mat<3,3,signed char>; using scmat4x3 = mat<4,3,signed char>;
        using scmat2x4 = mat<2,4,signed char>; using scmat3x4 = mat<3,4,signed char>; using scmat4x4 = mat<4,4,signed char>;
        using scmat2 = scmat2x2; using scmat3 = scmat3x3; using scmat4 = scmat4x4;
        
        template <int D> using svec = vec<D,short>;
        template <int W, int H> using smat = mat<W,H,short>;
        using svec2 = vec<2,short>; using svec3 = vec<3,short>; using svec4 = vec<4,short>;
        using smat2x2 = mat<2,2,short>; using smat3x2 = mat<3,2,short>; using smat4x2 = mat<4,2,short>;
        using smat2x3 = mat<2,3,short>; using smat3x3 = mat<3,3,short>; using smat4x3 = mat<4,3,short>;
        using smat2x4 = mat<2,4,short>; using smat3x4 = mat<3,4,short>; using smat4x4 = mat<4,4,short>;
        using smat2 = smat2x2; using smat3 = smat3x3; using smat4 = smat4x4;
        
        template <int D> using usvec = vec<D,unsigned short>;
        template <int W, int H> using usmat = mat<W,H,unsigned short>;
        using usvec2 = vec<2,unsigned short>; using usvec3 = vec<3,unsigned short>; using usvec4 = vec<4,unsigned short>;
        using usmat2x2 = mat<2,2,unsigned short>; using usmat3x2 = mat<3,2,unsigned short>; using usmat4x2 = mat<4,2,unsigned short>;
        using usmat2x3 = mat<2,3,unsigned short>; using usmat3x3 = mat<3,3,unsigned short>; using usmat4x3 = mat<4,3,unsigned short>;
        using usmat2x4 = mat<2,4,unsigned short>; using usmat3x4 = mat<3,4,unsigned short>; using usmat4x4 = mat<4,4,unsigned short>;
        using usmat2 = usmat2x2; using usmat3 = usmat3x3; using usmat4 = usmat4x4;
        
        template <int D> using ivec = vec<D,int>;
        template <int W, int H> using imat = mat<W,H,int>;
        using ivec2 = vec<2,int>; using ivec3 = vec<3,int>; using ivec4 = vec<4,int>;
        using imat2x2 = mat<2,2,int>; using imat3x2 = mat<3,2,int>; using imat4x2 = mat<4,2,int>;
        using imat2x3 = mat<2,3,int>; using imat3x3 = mat<3,3,int>; using imat4x3 = mat<4,3,int>;
        using imat2x4 = mat<2,4,int>; using imat3x4 = mat<3,4,int>; using imat4x4 = mat<4,4,int>;
        using imat2 = imat2x2; using imat3 = imat3x3; using imat4 = imat4x4;
        
        template <int D> using uvec = vec<D,unsigned int>;
        template <int W, int H> using umat = mat<W,H,unsigned int>;
        using uvec2 = vec<2,unsigned int>; using uvec3 = vec<3,unsigned int>; using uvec4 = vec<4,unsigned int>;
        using umat2x2 = mat<2,2,unsigned int>; using umat3x2 = mat<3,2,unsigned int>; using umat4x2 = mat<4,2,unsigned int>;
        using umat2x3 = mat<2,3,unsigned int>; using umat3x3 = mat<3,3,unsigned int>; using umat4x3 = mat<4,3,unsigned int>;
        using umat2x4 = mat<2,4,unsigned int>; using umat3x4 = mat<3,4,unsigned int>; using umat4x4 = mat<4,4,unsigned int>;
        using umat2 = umat2x2; using umat3 = umat3x3; using umat4 = umat4x4;
        
        template <int D> using lvec = vec<D,long>;
        template <int W, int H> using lmat = mat<W,H,long>;
        using lvec2 = vec<2,long>; using lvec3 = vec<3,long>; using lvec4 = vec<4,long>;
        using lmat2x2 = mat<2,2,long>; using lmat3x2 = mat<3,2,long>; using lmat4x2 = mat<4,2,long>;
        using lmat2x3 = mat<2,3,long>; using lmat3x3 = mat<3,3,long>; using lmat4x3 = mat<4,3,long>;
        using lmat2x4 = mat<2,4,long>; using lmat3x4 = mat<3,4,long>; using lmat4x4 = mat<4,4,long>;
        using lmat2 = lmat2x2; using lmat3 = lmat3x3; using lmat4 = lmat4x4;
        
        template <int D> using ulvec = vec<D,unsigned long>;
        template <int W, int H> using ulmat = mat<W,H,unsigned long>;
        using ulvec2 = vec<2,unsigned long>; using ulvec3 = vec<3,unsigned long>; using ulvec4 = vec<4,unsigned long>;
        using ulmat2x2 = mat<2,2,unsigned long>; using ulmat3x2 = mat<3,2,unsigned long>; using ulmat4x2 = mat<4,2,unsigned long>;
        using ulmat2x3 = mat<2,3,unsigned long>; using ulmat3x3 = mat<3,3,unsigned long>; using ulmat4x3 = mat<4,3,unsigned long>;
        using ulmat2x4 = mat<2,4,unsigned long>; using ulmat3x4 = mat<3,4,unsigned long>; using ulmat4x4 = mat<4,4,unsigned long>;
        using ulmat2 = ulmat2x2; using ulmat3 = ulmat3x3; using ulmat4 = ulmat4x4;
        
        template <int D> using llvec = vec<D,long long>;
        template <int W, int H> using llmat = mat<W,H,long long>;
        using llvec2 = vec<2,long long>; using llvec3 = vec<3,long long>; using llvec4 = vec<4,long long>;
        using llmat2x2 = mat<2,2,long long>; using llmat3x2 = mat<3,2,long long>; using llmat4x2 = mat<4,2,long long>;
        using llmat2x3 = mat<2,3,long long>; using llmat3x3 = mat<3,3,long long>; using llmat4x3 = mat<4,3,long long>;
        using llmat2x4 = mat<2,4,long long>; using llmat3x4 = mat<3,4,long long>; using llmat4x4 = mat<4,4,long long>;
        using llmat2 = llmat2x2; using llmat3 = llmat3x3; using llmat4 = llmat4x4;
        
        template <int D> using ullvec = vec<D,unsigned long long>;
        template <int W, int H> using ullmat = mat<W,H,unsigned long long>;
        using ullvec2 = vec<2,unsigned long long>; using ullvec3 = vec<3,unsigned long long>; using ullvec4 = vec<4,unsigned long long>;
        using ullmat2x2 = mat<2,2,unsigned long long>; using ullmat3x2 = mat<3,2,unsigned long long>; using ullmat4x2 = mat<4,2,unsigned long long>;
        using ullmat2x3 = mat<2,3,unsigned long long>; using ullmat3x3 = mat<3,3,unsigned long long>; using ullmat4x3 = mat<4,3,unsigned long long>;
        using ullmat2x4 = mat<2,4,unsigned long long>; using ullmat3x4 = mat<3,4,unsigned long long>; using ullmat4x4 = mat<4,4,unsigned long long>;
        using ullmat2 = ullmat2x2; using ullmat3 = ullmat3x3; using ullmat4 = ullmat4x4;
        
        template <int D> using fvec = vec<D,float>;
        template <int W, int H> using fmat = mat<W,H,float>;
        using fvec2 = vec<2,float>; using fvec3 = vec<3,float>; using fvec4 = vec<4,float>;
        using fmat2x2 = mat<2,2,float>; using fmat3x2 = mat<3,2,float>; using fmat4x2 = mat<4,2,float>;
        using fmat2x3 = mat<2,3,float>; using fmat3x3 = mat<3,3,float>; using fmat4x3 = mat<4,3,float>;
        using fmat2x4 = mat<2,4,float>; using fmat3x4 = mat<3,4,float>; using fmat4x4 = mat<4,4,float>;
        using fmat2 = fmat2x2; using fmat3 = fmat3x3; using fmat4 = fmat4x4;
        
        template <int D> using dvec = vec<D,double>;
        template <int W, int H> using dmat = mat<W,H,double>;
        using dvec2 = vec<2,double>; using dvec3 = vec<3,double>; using dvec4 = vec<4,double>;
        using dmat2x2 = mat<2,2,double>; using dmat3x2 = mat<3,2,double>; using dmat4x2 = mat<4,2,double>;
        using dmat2x3 = mat<2,3,double>; using dmat3x3 = mat<3,3,double>; using dmat4x3 = mat<4,3,double>;
        using dmat2x4 = mat<2,4,double>; using dmat3x4 = mat<3,4,double>; using dmat4x4 = mat<4,4,double>;
        using dmat2 = dmat2x2; using dmat3 = dmat3x3; using dmat4 = dmat4x4;
        
        template <int D> using ldvec = vec<D,long double>;
        template <int W, int H> using ldmat = mat<W,H,long double>;
        using ldvec2 = vec<2,long double>; using ldvec3 = vec<3,long double>; using ldvec4 = vec<4,long double>;
        using ldmat2x2 = mat<2,2,long double>; using ldmat3x2 = mat<3,2,long double>; using ldmat4x2 = mat<4,2,long double>;
        using ldmat2x3 = mat<2,3,long double>; using ldmat3x3 = mat<3,3,long double>; using ldmat4x3 = mat<4,3,long double>;
        using ldmat2x4 = mat<2,4,long double>; using ldmat3x4 = mat<3,4,long double>; using ldmat4x4 = mat<4,4,long double>;
        using ldmat2 = ldmat2x2; using ldmat3 = ldmat3x3; using ldmat4 = ldmat4x4;
        
        template <int D> using i8vec = vec<D,int8_t>;
        template <int W, int H> using i8mat = mat<W,H,int8_t>;
        using i8vec2 = vec<2,int8_t>; using i8vec3 = vec<3,int8_t>; using i8vec4 = vec<4,int8_t>;
        using i8mat2x2 = mat<2,2,int8_t>; using i8mat3x2 = mat<3,2,int8_t>; using i8mat4x2 = mat<4,2,int8_t>;
        using i8mat2x3 = mat<2,3,int8_t>; using i8mat3x3 = mat<3,3,int8_t>; using i8mat4x3 = mat<4,3,int8_t>;
        using i8mat2x4 = mat<2,4,int8_t>; using i8mat3x4 = mat<3,4,int8_t>; using i8mat4x4 = mat<4,4,int8_t>;
        using i8mat2 = i8mat2x2; using i8mat3 = i8mat3x3; using i8mat4 = i8mat4x4;
        
        template <int D> using u8vec = vec<D,uint8_t>;
        template <int W, int H> using u8mat = mat<W,H,uint8_t>;
        using u8vec2 = vec<2,uint8_t>; using u8vec3 = vec<3,uint8_t>; using u8vec4 = vec<4,uint8_t>;
        using u8mat2x2 = mat<2,2,uint8_t>; using u8mat3x2 = mat<3,2,uint8_t>; using u8mat4x2 = mat<4,2,uint8_t>;
        using u8mat2x3 = mat<2,3,uint8_t>; using u8mat3x3 = mat<3,3,uint8_t>; using u8mat4x3 = mat<4,3,uint8_t>;
        using u8mat2x4 = mat<2,4,uint8_t>; using u8mat3x4 = mat<3,4,uint8_t>; using u8mat4x4 = mat<4,4,uint8_t>;
        using u8mat2 = u8mat2x2; using u8mat3 = u8mat3x3; using u8mat4 = u8mat4x4;
        
        template <int D> using i16vec = vec<D,int16_t>;
        template <int W, int H> using i16mat = mat<W,H,int16_t>;
        using i16vec2 = vec<2,int16_t>; using i16vec3 = vec<3,int16_t>; using i16vec4 = vec<4,int16_t>;
        using i16mat2x2 = mat<2,2,int16_t>; using i16mat3x2 = mat<3,2,int16_t>; using i16mat4x2 = mat<4,2,int16_t>;
        using i16mat2x3 = mat<2,3,int16_t>; using i16mat3x3 = mat<3,3,int16_t>; using i16mat4x3 = mat<4,3,int16_t>;
        using i16mat2x4 = mat<2,4,int16_t>; using i16mat3x4 = mat<3,4,int16_t>; using i16mat4x4 = mat<4,4,int16_t>;
        using i16mat2 = i16mat2x2; using i16mat3 = i16mat3x3; using i16mat4 = i16mat4x4;
        
        template <int D> using u16vec = vec<D,uint16_t>;
        template <int W, int H> using u16mat = mat<W,H,uint16_t>;
        using u16vec2 = vec<2,uint16_t>; using u16vec3 = vec<3,uint16_t>; using u16vec4 = vec<4,uint16_t>;
        using u16mat2x2 = mat<2,2,uint16_t>; using u16mat3x2 = mat<3,2,uint16_t>; using u16mat4x2 = mat<4,2,uint16_t>;
        using u16mat2x3 = mat<2,3,uint16_t>; using u16mat3x3 = mat<3,3,uint16_t>; using u16mat4x3 = mat<4,3,uint16_t>;
        using u16mat2x4 = mat<2,4,uint16_t>; using u16mat3x4 = mat<3,4,uint16_t>; using u16mat4x4 = mat<4,4,uint16_t>;
        using u16mat2 = u16mat2x2; using u16mat3 = u16mat3x3; using u16mat4 = u16mat4x4;
        
        template <int D> using i32vec = vec<D,int32_t>;
        template <int W, int H> using i32mat = mat<W,H,int32_t>;
        using i32vec2 = vec<2,int32_t>; using i32vec3 = vec<3,int32_t>; using i32vec4 = vec<4,int32_t>;
        using i32mat2x2 = mat<2,2,int32_t>; using i32mat3x2 = mat<3,2,int32_t>; using i32mat4x2 = mat<4,2,int32_t>;
        using i32mat2x3 = mat<2,3,int32_t>; using i32mat3x3 = mat<3,3,int32_t>; using i32mat4x3 = mat<4,3,int32_t>;
        using i32mat2x4 = mat<2,4,int32_t>; using i32mat3x4 = mat<3,4,int32_t>; using i32mat4x4 = mat<4,4,int32_t>;
        using i32mat2 = i32mat2x2; using i32mat3 = i32mat3x3; using i32mat4 = i32mat4x4;
        
        template <int D> using u32vec = vec<D,uint32_t>;
        template <int W, int H> using u32mat = mat<W,H,uint32_t>;
        using u32vec2 = vec<2,uint32_t>; using u32vec3 = vec<3,uint32_t>; using u32vec4 = vec<4,uint32_t>;
        using u32mat2x2 = mat<2,2,uint32_t>; using u32mat3x2 = mat<3,2,uint32_t>; using u32mat4x2 = mat<4,2,uint32_t>;
        using u32mat2x3 = mat<2,3,uint32_t>; using u32mat3x3 = mat<3,3,uint32_t>; using u32mat4x3 = mat<4,3,uint32_t>;
        using u32mat2x4 = mat<2,4,uint32_t>; using u32mat3x4 = mat<3,4,uint32_t>; using u32mat4x4 = mat<4,4,uint32_t>;
        using u32mat2 = u32mat2x2; using u32mat3 = u32mat3x3; using u32mat4 = u32mat4x4;
        
        template <int D> using i64vec = vec<D,int64_t>;
        template <int W, int H> using i64mat = mat<W,H,int64_t>;
        using i64vec2 = vec<2,int64_t>; using i64vec3 = vec<3,int64_t>; using i64vec4 = vec<4,int64_t>;
        using i64mat2x2 = mat<2,2,int64_t>; using i64mat3x2 = mat<3,2,int64_t>; using i64mat4x2 = mat<4,2,int64_t>;
        using i64mat2x3 = mat<2,3,int64_t>; using i64mat3x3 = mat<3,3,int64_t>; using i64mat4x3 = mat<4,3,int64_t>;
        using i64mat2x4 = mat<2,4,int64_t>; using i64mat3x4 = mat<3,4,int64_t>; using i64mat4x4 = mat<4,4,int64_t>;
        using i64mat2 = i64mat2x2; using i64mat3 = i64mat3x3; using i64mat4 = i64mat4x4;
        
        template <int D> using u64vec = vec<D,uint64_t>;
        template <int W, int H> using u64mat = mat<W,H,uint64_t>;
        using u64vec2 = vec<2,uint64_t>; using u64vec3 = vec<3,uint64_t>; using u64vec4 = vec<4,uint64_t>;
        using u64mat2x2 = mat<2,2,uint64_t>; using u64mat3x2 = mat<3,2,uint64_t>; using u64mat4x2 = mat<4,2,uint64_t>;
        using u64mat2x3 = mat<2,3,uint64_t>; using u64mat3x3 = mat<3,3,uint64_t>; using u64mat4x3 = mat<4,3,uint64_t>;
        using u64mat2x4 = mat<2,4,uint64_t>; using u64mat3x4 = mat<3,4,uint64_t>; using u64mat4x4 = mat<4,4,uint64_t>;
        using u64mat2 = u64mat2x2; using u64mat3 = u64mat3x3; using u64mat4 = u64mat4x4;
    }
    
    inline namespace Utility
    {
        template <typename T> struct properties
        {
            static constexpr bool
                is_vec        = 0,
                is_mat        = 0,
                is_vec_or_mat = 0;
        };
        template <int D, typename T> struct properties<vec<D,T>>
        {
            static constexpr bool
                is_vec        = 1,
                is_mat        = 0,
                is_vec_or_mat = 1;
        };
        template <int W, int H, typename T> struct properties<vec<W,vec<H,T>>>
        {
            static constexpr bool
                is_vec        = 0,
                is_mat        = 1,
                is_vec_or_mat = 1;
        };
        
        template <typename A, typename B> inline constexpr bool same_size_v = properties<A>::w == properties<B>::w && properties<A>::h == properties<B>::h;
        
        template <typename T> struct base_impl {using type = T;};
        template <int D, typename T> struct base_impl<vec<D,T>> {using type = typename base_impl<T>::type;};
        template <typename T> using base_t = typename base_impl<T>::type;
        
        template <typename T, typename TT> struct change_base_impl {using type = base_t<TT>;};
        template <int D, typename T, typename TT> struct change_base_impl<vec<D,T>,TT> {using type = vec<D, typename change_base_impl<T, TT>::type>;};
        template <typename T, typename TT> using change_base_t = typename change_base_impl<T,TT>::type;
        
        template <typename A, typename B> inline constexpr bool same_size_v = std::is_same_v<A, change_base_t<B,A>>;
        
        template <typename T> struct floating_point_impl {using type = std::conditional_t<std::is_floating_point_v<base_t<T>>, T, change_base_t<T, double>>;};
        template <typename T> using floating_point_t = typename floating_point_impl<T>::type;
        
        template <typename T> struct type_weight
        {
            static constexpr std::size_t
                high = std::is_floating_point_v<base_t<T>> * 0x100,
                mid  = sizeof(base_t<T>),
                low  = 0x100;
        };
        
        template <typename A, typename B> inline constexpr int compare_weight_v =
            type_weight<A>::high < type_weight<B>::high ? -1 :
            type_weight<A>::high > type_weight<B>::high ?  1 :
            type_weight<A>::mid  < type_weight<B>::mid  ? -1 :
            type_weight<A>::mid  > type_weight<B>::mid  ?  1 :
            type_weight<A>::low  < type_weight<B>::low  ? -1 :
            type_weight<A>::low  > type_weight<B>::low  ?  1 : 0;
        
        template <typename ...P> struct larger_impl {using type = void;};
        template <typename T> struct larger_impl<T> {using type = T;};
        template <typename T, typename ...P> struct larger_impl<T,P...> {using type = typename larger_impl<T, typename larger_impl<P...>::type>::type;};
        template <typename A, typename B> struct larger_impl<A,B> {using type = std::conditional_t<compare_weight_v<A,B> == 0, void, std::conditional_t<(compare_weight_v<A,B> > 0), A, B>>;};
        template <int D, typename A, typename B> struct larger_impl<vec<D,A>,B> {using type = change_base_t<vec<D,A>, typename larger_impl<A,B>::type>;};
        template <int D, typename A, typename B> struct larger_impl<B,vec<D,A>> {using type = change_base_t<vec<D,A>, typename larger_impl<A,B>::type>;};
        template <int DA, int DB, typename A, typename B> struct larger_impl<vec<DA,A>,vec<DB,B>>
        {using type = std::conditional_t<same_size_v<vec<DA,A>,vec<DB,B>>, change_base_t<vec<DA,A>, typename larger_impl<A,B>::type>, void>;};
        
        // Void on failure
        template <typename ...P> using opt_larger_t = typename larger_impl<P...>::type; // void on failure
        
        template <typename ...P> inline constexpr bool have_larger_type_v = !std::is_void_v<opt_larger_t<P...>>;
        
        // Soft error on failure
        template <typename ...P> using soft_larger_t = std::enable_if_t<have_larger_type_v<P...>, opt_larger_t<P...>>;
        
        template <typename ...P> struct hard_larger_impl
        {
            static_assert(have_larger_type_v<P...>, "Can't determine larger type.");
            using type = opt_larger_t<P...>;
        };
        
        // Hard error on failure
        template <typename ...P> using larger_t = typename hard_larger_impl<P...>::type;
        
        template <typename A, typename B> struct copy_qualifiers_impl {using type = B;};
        template <typename A, typename B> struct copy_qualifiers_impl<const A, B> {using type = const typename copy_qualifiers_impl<A,B>::type;};
        template <typename A, typename B> struct copy_qualifiers_impl<A &, B> {using type = typename copy_qualifiers_impl<A,B>::type &;};
        template <typename A, typename B> struct copy_qualifiers_impl<A &&, B> {using type = typename copy_qualifiers_impl<A,B>::type &&;};
        template <typename A, typename B> using copy_qualifiers_t = typename copy_qualifiers_impl<A,B>::type;
        
        template <typename T> using propagate_qualifiers_t = copy_qualifiers_t<base_t<T>, change_base_t<T, std::remove_const_t<std::remove_reference_t<base_t<T>>>>>;
    }
    
    inline namespace Vector
    {
        //{ Vectors
        template <typename T> struct vec<2,T> // vec2
        {
            static_assert(!std::is_const_v<T> && !std::is_volatile_v<T>, "The base type must have no cv-qualifiers.");
            static constexpr int size = 2;
            using type = T;
            using member_type = T;
            union {member_type x, r, s;};
            union {member_type y, g, t;};
            constexpr vec() = default;
            explicit constexpr vec(member_type obj) : x(obj), y(obj) {}
            constexpr vec(member_type x, member_type y) : x(x), y(y) {}
            template <typename TT> constexpr vec(const vec2<TT> &obj) : x(obj.x), y(obj.y) {}
            template <typename TT> [[nodiscard]] constexpr vec2<TT> to() const {return vec2<TT>(TT(x), TT(y));}
            static constexpr member_type vec::*pointers[size] {&vec::x, &vec::y};
            [[nodiscard]] constexpr member_type &operator[](int i) {return *this.*pointers[i];}
            [[nodiscard]] constexpr const member_type &operator[](int i) const {return *this.*pointers[i];}
            [[nodiscard]] type *as_array() {return &x;};
            [[nodiscard]] const type *as_array() const {return &x;};
            [[nodiscard]] explicit constexpr operator bool() const {return this->any(); static_assert(!std::is_same_v<type, bool>, "Use .none(), .any(), or .all() for vectors/matrices of bool.");}
            [[nodiscard]] constexpr bool none() const {return !this->any();}
            [[nodiscard]] constexpr bool any() const {return x || y;}
            [[nodiscard]] constexpr bool all() const {return x && y;}
            [[nodiscard]] constexpr auto sum() const {return x + y;}
            [[nodiscard]] constexpr auto prod() const {return x * y;}
            [[nodiscard]] constexpr auto ratio() const {return x / y;}
            [[nodiscard]] constexpr type min() const {return std::min({x,y});}
            [[nodiscard]] constexpr type max() const {return std::max({x,y});}
        };
        
        template <typename T> struct vec<3,T> // vec3
        {
            static_assert(!std::is_const_v<T> && !std::is_volatile_v<T>, "The base type must have no cv-qualifiers.");
            static constexpr int size = 3;
            using type = T;
            using member_type = T;
            union {member_type x, r, s;};
            union {member_type y, g, t;};
            union {member_type z, b, p;};
            constexpr vec() = default;
            explicit constexpr vec(member_type obj) : x(obj), y(obj), z(obj) {}
            constexpr vec(member_type x, member_type y, member_type z) : x(x), y(y), z(z) {}
            template <typename TT> constexpr vec(const vec3<TT> &obj) : x(obj.x), y(obj.y), z(obj.z) {}
            template <typename TT> [[nodiscard]] constexpr vec3<TT> to() const {return vec3<TT>(TT(x), TT(y), TT(z));}
            static constexpr member_type vec::*pointers[size] {&vec::x, &vec::y, &vec::z};
            [[nodiscard]] constexpr member_type &operator[](int i) {return *this.*pointers[i];}
            [[nodiscard]] constexpr const member_type &operator[](int i) const {return *this.*pointers[i];}
            [[nodiscard]] type *as_array() {return &x;};
            [[nodiscard]] const type *as_array() const {return &x;};
            [[nodiscard]] explicit constexpr operator bool() const {return this->any(); static_assert(!std::is_same_v<type, bool>, "Use .none(), .any(), or .all() for vectors/matrices of bool.");}
            [[nodiscard]] constexpr bool none() const {return !this->any();}
            [[nodiscard]] constexpr bool any() const {return x || y || z;}
            [[nodiscard]] constexpr bool all() const {return x && y && z;}
            [[nodiscard]] constexpr auto sum() const {return x + y + z;}
            [[nodiscard]] constexpr auto prod() const {return x * y * z;}
            [[nodiscard]] constexpr type min() const {return std::min({x,y,z});}
            [[nodiscard]] constexpr type max() const {return std::max({x,y,z});}
        };
        
        template <typename T> struct vec<4,T> // vec4
        {
            static_assert(!std::is_const_v<T> && !std::is_volatile_v<T>, "The base type must have no cv-qualifiers.");
            static constexpr int size = 4;
            using type = T;
            using member_type = T;
            union {member_type x, r, s;};
            union {member_type y, g, t;};
            union {member_type z, b, p;};
            union {member_type w, a, q;};
            constexpr vec() = default;
            explicit constexpr vec(member_type obj) : x(obj), y(obj), z(obj), w(obj) {}
            constexpr vec(member_type x, member_type y, member_type z, member_type w) : x(x), y(y), z(z), w(w) {}
            template <typename TT> constexpr vec(const vec4<TT> &obj) : x(obj.x), y(obj.y), z(obj.z), w(obj.w) {}
            template <typename TT> [[nodiscard]] constexpr vec4<TT> to() const {return vec4<TT>(TT(x), TT(y), TT(z), TT(w));}
            static constexpr member_type vec::*pointers[size] {&vec::x, &vec::y, &vec::z, &vec::w};
            [[nodiscard]] constexpr member_type &operator[](int i) {return *this.*pointers[i];}
            [[nodiscard]] constexpr const member_type &operator[](int i) const {return *this.*pointers[i];}
            [[nodiscard]] type *as_array() {return &x;};
            [[nodiscard]] const type *as_array() const {return &x;};
            [[nodiscard]] explicit constexpr operator bool() const {return this->any(); static_assert(!std::is_same_v<type, bool>, "Use .none(), .any(), or .all() for vectors/matrices of bool.");}
            [[nodiscard]] constexpr bool none() const {return !this->any();}
            [[nodiscard]] constexpr bool any() const {return x || y || z || w;}
            [[nodiscard]] constexpr bool all() const {return x && y && z && w;}
            [[nodiscard]] constexpr auto sum() const {return x + y + z + w;}
            [[nodiscard]] constexpr auto prod() const {return x * y * z * w;}
            [[nodiscard]] constexpr type min() const {return std::min({x,y,z,w});}
            [[nodiscard]] constexpr type max() const {return std::max({x,y,z,w});}
        };
        //} Vectors
        
        //{ Matrices
        template <typename T> struct vec<2,vec<2,T>> // mat2x2
        {
            static_assert(!std::is_const_v<T> && !std::is_volatile_v<T>, "The base type must have no cv-qualifiers.");
            static constexpr int width = 2, height = 2;
            static constexpr int size = 2;
            using type = T;
            using member_type = vec2<T>;
            union {member_type x, r, s;};
            union {member_type y, g, t;};
            constexpr vec() = default;
            explicit constexpr vec(member_type obj) : x(obj), y(obj) {}
            constexpr vec(member_type x, member_type y) : x(x), y(y) {}
            explicit constexpr vec(type obj) : x(obj), y(obj) {}
            constexpr vec(type xx, type yx, type xy, type yy) : x(xx,xy), y(yx,yy) {}
            template <typename TT> constexpr vec(const mat2x2<TT> &obj) : x(obj.x), y(obj.y) {}
            template <typename TT> [[nodiscard]] constexpr mat2x2<TT> to() const {return mat2x2<TT>(TT(x.x), TT(y.x), TT(x.y), TT(y.y));}
            static constexpr member_type vec::*pointers[width] {&vec::x, &vec::y};
            [[nodiscard]] constexpr member_type &operator[](int i) {return *this.*pointers[i];}
            [[nodiscard]] constexpr const member_type &operator[](int i) const {return *this.*pointers[i];}
            [[nodiscard]] type *as_array() {return &x.x;};
            [[nodiscard]] const type *as_array() const {return &x.x;};
            [[nodiscard]] explicit constexpr operator bool() const {return this->any(); static_assert(!std::is_same_v<type, bool>, "Use .none(), .any(), or .all() for vectors/matrices of bool.");}
            [[nodiscard]] constexpr bool none() const {return !this->any();}
            [[nodiscard]] constexpr bool any() const {return x.x || x.y || y.x || y.y;}
            [[nodiscard]] constexpr bool all() const {return x.x && x.y && y.x && y.y;}
            [[nodiscard]] constexpr type min() const {return std::min({x.x,x.y,y.x,y.y});}
            [[nodiscard]] constexpr type max() const {return std::max({x.x,x.y,y.x,y.y});}
        };
        
        template <typename T> struct vec<2,vec<3,T>> // mat2x3
        {
            static_assert(!std::is_const_v<T> && !std::is_volatile_v<T>, "The base type must have no cv-qualifiers.");
            static constexpr int width = 2, height = 3;
            using type = T;
            using member_type = vec3<T>;
            union {member_type x, r, s;};
            union {member_type y, g, t;};
            constexpr vec() = default;
            explicit constexpr vec(member_type obj) : x(obj), y(obj) {}
            constexpr vec(member_type x, member_type y) : x(x), y(y) {}
            explicit constexpr vec(type obj) : x(obj), y(obj) {}
            constexpr vec(type xx, type yx, type xy, type yy, type xz, type yz) : x(xx,xy,xz), y(yx,yy,yz) {}
            template <typename TT> constexpr vec(const mat2x3<TT> &obj) : x(obj.x), y(obj.y) {}
            template <typename TT> [[nodiscard]] constexpr mat2x3<TT> to() const {return mat2x3<TT>(TT(x.x), TT(y.x), TT(x.y), TT(y.y), TT(x.z), TT(y.z));}
            static constexpr member_type vec::*pointers[width] {&vec::x, &vec::y};
            [[nodiscard]] constexpr member_type &operator[](int i) {return *this.*pointers[i];}
            [[nodiscard]] constexpr const member_type &operator[](int i) const {return *this.*pointers[i];}
            [[nodiscard]] type *as_array() {return &x.x;};
            [[nodiscard]] const type *as_array() const {return &x.x;};
            [[nodiscard]] explicit constexpr operator bool() const {return this->any(); static_assert(!std::is_same_v<type, bool>, "Use .none(), .any(), or .all() for vectors/matrices of bool.");}
            [[nodiscard]] constexpr bool none() const {return !this->any();}
            [[nodiscard]] constexpr bool any() const {return x.x || x.y || x.z || y.x || y.y || y.z;}
            [[nodiscard]] constexpr bool all() const {return x.x && x.y && x.z && y.x && y.y && y.z;}
            [[nodiscard]] constexpr type min() const {return std::min({x.x,x.y,x.z,y.x,y.y,y.z});}
            [[nodiscard]] constexpr type max() const {return std::max({x.x,x.y,x.z,y.x,y.y,y.z});}
        };
        
        template <typename T> struct vec<2,vec<4,T>> // mat2x4
        {
            static_assert(!std::is_const_v<T> && !std::is_volatile_v<T>, "The base type must have no cv-qualifiers.");
            static constexpr int width = 2, height = 4;
            using type = T;
            using member_type = vec4<T>;
            union {member_type x, r, s;};
            union {member_type y, g, t;};
            constexpr vec() = default;
            explicit constexpr vec(member_type obj) : x(obj), y(obj) {}
            constexpr vec(member_type x, member_type y) : x(x), y(y) {}
            explicit constexpr vec(type obj) : x(obj), y(obj) {}
            constexpr vec(type xx, type yx, type xy, type yy, type xz, type yz, type xw, type yw) : x(xx,xy,xz,xw), y(yx,yy,yz,yw) {}
            template <typename TT> constexpr vec(const mat2x4<TT> &obj) : x(obj.x), y(obj.y) {}
            template <typename TT> [[nodiscard]] constexpr mat2x4<TT> to() const {return mat2x4<TT>(TT(x.x), TT(y.x), TT(x.y), TT(y.y), TT(x.z), TT(y.z), TT(x.w), TT(y.w));}
            static constexpr member_type vec::*pointers[width] {&vec::x, &vec::y};
            [[nodiscard]] constexpr member_type &operator[](int i) {return *this.*pointers[i];}
            [[nodiscard]] constexpr const member_type &operator[](int i) const {return *this.*pointers[i];}
            [[nodiscard]] type *as_array() {return &x.x;};
            [[nodiscard]] const type *as_array() const {return &x.x;};
            [[nodiscard]] explicit constexpr operator bool() const {return this->any(); static_assert(!std::is_same_v<type, bool>, "Use .none(), .any(), or .all() for vectors/matrices of bool.");}
            [[nodiscard]] constexpr bool none() const {return !this->any();}
            [[nodiscard]] constexpr bool any() const {return x.x || x.y || x.z || x.w || y.x || y.y || y.z || y.w;}
            [[nodiscard]] constexpr bool all() const {return x.x && x.y && x.z && x.w && y.x && y.y && y.z && y.w;}
            [[nodiscard]] constexpr type min() const {return std::min({x.x,x.y,x.z,x.w,y.x,y.y,y.z,y.w});}
            [[nodiscard]] constexpr type max() const {return std::max({x.x,x.y,x.z,x.w,y.x,y.y,y.z,y.w});}
        };
        
        template <typename T> struct vec<3,vec<2,T>> // mat3x2
        {
            static_assert(!std::is_const_v<T> && !std::is_volatile_v<T>, "The base type must have no cv-qualifiers.");
            static constexpr int width = 3, height = 2;
            using type = T;
            using member_type = vec2<T>;
            union {member_type x, r, s;};
            union {member_type y, g, t;};
            union {member_type z, b, p;};
            constexpr vec() = default;
            explicit constexpr vec(member_type obj) : x(obj), y(obj), z(obj) {}
            constexpr vec(member_type x, member_type y, member_type z) : x(x), y(y), z(z) {}
            explicit constexpr vec(type obj) : x(obj), y(obj), z(obj) {}
            constexpr vec(type xx, type yx, type zx, type xy, type yy, type zy) : x(xx,xy), y(yx,yy), z(zx,zy) {}
            template <typename TT> constexpr vec(const mat3x2<TT> &obj) : x(obj.x), y(obj.y), z(obj.z) {}
            template <typename TT> [[nodiscard]] constexpr mat3x2<TT> to() const {return mat3x2<TT>(TT(x.x), TT(y.x), TT(z.x), TT(x.y), TT(y.y), TT(z.y));}
            static constexpr member_type vec::*pointers[width] {&vec::x, &vec::y, &vec::z};
            [[nodiscard]] constexpr member_type &operator[](int i) {return *this.*pointers[i];}
            [[nodiscard]] constexpr const member_type &operator[](int i) const {return *this.*pointers[i];}
            [[nodiscard]] type *as_array() {return &x.x;};
            [[nodiscard]] const type *as_array() const {return &x.x;};
            [[nodiscard]] explicit constexpr operator bool() const {return this->any(); static_assert(!std::is_same_v<type, bool>, "Use .none(), .any(), or .all() for vectors/matrices of bool.");}
            [[nodiscard]] constexpr bool none() const {return !this->any();}
            [[nodiscard]] constexpr bool any() const {return x.x || x.y || y.x || y.y || z.x || z.y;}
            [[nodiscard]] constexpr bool all() const {return x.x && x.y && y.x && y.y && z.x && z.y;}
            [[nodiscard]] constexpr type min() const {return std::min({x.x,x.y,y.x,y.y,z.x,z.y});}
            [[nodiscard]] constexpr type max() const {return std::max({x.x,x.y,y.x,y.y,z.x,z.y});}
        };
        
        template <typename T> struct vec<3,vec<3,T>> // mat3x3
        {
            static_assert(!std::is_const_v<T> && !std::is_volatile_v<T>, "The base type must have no cv-qualifiers.");
            static constexpr int width = 3, height = 3;
            static constexpr int size = 3;
            using type = T;
            using member_type = vec3<T>;
            union {member_type x, r, s;};
            union {member_type y, g, t;};
            union {member_type z, b, p;};
            constexpr vec() = default;
            explicit constexpr vec(member_type obj) : x(obj), y(obj), z(obj) {}
            constexpr vec(member_type x, member_type y, member_type z) : x(x), y(y), z(z) {}
            explicit constexpr vec(type obj) : x(obj), y(obj), z(obj) {}
            constexpr vec(type xx, type yx, type zx, type xy, type yy, type zy, type xz, type yz, type zz) : x(xx,xy,xz), y(yx,yy,yz), z(zx,zy,zz) {}
            template <typename TT> constexpr vec(const mat3x3<TT> &obj) : x(obj.x), y(obj.y), z(obj.z) {}
            template <typename TT> [[nodiscard]] constexpr mat3x3<TT> to() const {return mat3x3<TT>(TT(x.x), TT(y.x), TT(z.x), TT(x.y), TT(y.y), TT(z.y), TT(x.z), TT(y.z), TT(z.z));}
            static constexpr member_type vec::*pointers[width] {&vec::x, &vec::y, &vec::z};
            [[nodiscard]] constexpr member_type &operator[](int i) {return *this.*pointers[i];}
            [[nodiscard]] constexpr const member_type &operator[](int i) const {return *this.*pointers[i];}
            [[nodiscard]] type *as_array() {return &x.x;};
            [[nodiscard]] const type *as_array() const {return &x.x;};
            [[nodiscard]] explicit constexpr operator bool() const {return this->any(); static_assert(!std::is_same_v<type, bool>, "Use .none(), .any(), or .all() for vectors/matrices of bool.");}
            [[nodiscard]] constexpr bool none() const {return !this->any();}
            [[nodiscard]] constexpr bool any() const {return x.x || x.y || x.z || y.x || y.y || y.z || z.x || z.y || z.z;}
            [[nodiscard]] constexpr bool all() const {return x.x && x.y && x.z && y.x && y.y && y.z && z.x && z.y && z.z;}
            [[nodiscard]] constexpr type min() const {return std::min({x.x,x.y,x.z,y.x,y.y,y.z,z.x,z.y,z.z});}
            [[nodiscard]] constexpr type max() const {return std::max({x.x,x.y,x.z,y.x,y.y,y.z,z.x,z.y,z.z});}
        };
        
        template <typename T> struct vec<3,vec<4,T>> // mat3x4
        {
            static_assert(!std::is_const_v<T> && !std::is_volatile_v<T>, "The base type must have no cv-qualifiers.");
            static constexpr int width = 3, height = 4;
            using type = T;
            using member_type = vec4<T>;
            union {member_type x, r, s;};
            union {member_type y, g, t;};
            union {member_type z, b, p;};
            constexpr vec() = default;
            explicit constexpr vec(member_type obj) : x(obj), y(obj), z(obj) {}
            constexpr vec(member_type x, member_type y, member_type z) : x(x), y(y), z(z) {}
            explicit constexpr vec(type obj) : x(obj), y(obj), z(obj) {}
            constexpr vec(type xx, type yx, type zx, type xy, type yy, type zy, type xz, type yz, type zz, type xw, type yw, type zw) : x(xx,xy,xz,xw), y(yx,yy,yz,yw), z(zx,zy,zz,zw) {}
            template <typename TT> constexpr vec(const mat3x4<TT> &obj) : x(obj.x), y(obj.y), z(obj.z) {}
            template <typename TT> [[nodiscard]] constexpr mat3x4<TT> to() const {return mat3x4<TT>(TT(x.x), TT(y.x), TT(z.x), TT(x.y), TT(y.y), TT(z.y), TT(x.z), TT(y.z), TT(z.z), TT(x.w), TT(y.w), TT(z.w));}
            static constexpr member_type vec::*pointers[width] {&vec::x, &vec::y, &vec::z};
            [[nodiscard]] constexpr member_type &operator[](int i) {return *this.*pointers[i];}
            [[nodiscard]] constexpr const member_type &operator[](int i) const {return *this.*pointers[i];}
            [[nodiscard]] type *as_array() {return &x.x;};
            [[nodiscard]] const type *as_array() const {return &x.x;};
            [[nodiscard]] explicit constexpr operator bool() const {return this->any(); static_assert(!std::is_same_v<type, bool>, "Use .none(), .any(), or .all() for vectors/matrices of bool.");}
            [[nodiscard]] constexpr bool none() const {return !this->any();}
            [[nodiscard]] constexpr bool any() const {return x.x || x.y || x.z || x.w || y.x || y.y || y.z || y.w || z.x || z.y || z.z || z.w;}
            [[nodiscard]] constexpr bool all() const {return x.x && x.y && x.z && x.w && y.x && y.y && y.z && y.w && z.x && z.y && z.z && z.w;}
            [[nodiscard]] constexpr type min() const {return std::min({x.x,x.y,x.z,x.w,y.x,y.y,y.z,y.w,z.x,z.y,z.z,z.w});}
            [[nodiscard]] constexpr type max() const {return std::max({x.x,x.y,x.z,x.w,y.x,y.y,y.z,y.w,z.x,z.y,z.z,z.w});}
        };
        
        template <typename T> struct vec<4,vec<2,T>> // mat4x2
        {
            static_assert(!std::is_const_v<T> && !std::is_volatile_v<T>, "The base type must have no cv-qualifiers.");
            static constexpr int width = 4, height = 2;
            using type = T;
            using member_type = vec2<T>;
            union {member_type x, r, s;};
            union {member_type y, g, t;};
            union {member_type z, b, p;};
            union {member_type w, a, q;};
            constexpr vec() = default;
            explicit constexpr vec(member_type obj) : x(obj), y(obj), z(obj), w(obj) {}
            constexpr vec(member_type x, member_type y, member_type z, member_type w) : x(x), y(y), z(z), w(w) {}
            explicit constexpr vec(type obj) : x(obj), y(obj), z(obj), w(obj) {}
            constexpr vec(type xx, type yx, type zx, type wx, type xy, type yy, type zy, type wy) : x(xx,xy), y(yx,yy), z(zx,zy), w(wx,wy) {}
            template <typename TT> constexpr vec(const mat4x2<TT> &obj) : x(obj.x), y(obj.y), z(obj.z), w(obj.w) {}
            template <typename TT> [[nodiscard]] constexpr mat4x2<TT> to() const {return mat4x2<TT>(TT(x.x), TT(y.x), TT(z.x), TT(w.x), TT(x.y), TT(y.y), TT(z.y), TT(w.y));}
            static constexpr member_type vec::*pointers[width] {&vec::x, &vec::y, &vec::z, &vec::w};
            [[nodiscard]] constexpr member_type &operator[](int i) {return *this.*pointers[i];}
            [[nodiscard]] constexpr const member_type &operator[](int i) const {return *this.*pointers[i];}
            [[nodiscard]] type *as_array() {return &x.x;};
            [[nodiscard]] const type *as_array() const {return &x.x;};
            [[nodiscard]] explicit constexpr operator bool() const {return this->any(); static_assert(!std::is_same_v<type, bool>, "Use .none(), .any(), or .all() for vectors/matrices of bool.");}
            [[nodiscard]] constexpr bool none() const {return !this->any();}
            [[nodiscard]] constexpr bool any() const {return x.x || x.y || y.x || y.y || z.x || z.y || w.x || w.y;}
            [[nodiscard]] constexpr bool all() const {return x.x && x.y && y.x && y.y && z.x && z.y && w.x && w.y;}
            [[nodiscard]] constexpr type min() const {return std::min({x.x,x.y,y.x,y.y,z.x,z.y,w.x,w.y});}
            [[nodiscard]] constexpr type max() const {return std::max({x.x,x.y,y.x,y.y,z.x,z.y,w.x,w.y});}
        };
        
        template <typename T> struct vec<4,vec<3,T>> // mat4x3
        {
            static_assert(!std::is_const_v<T> && !std::is_volatile_v<T>, "The base type must have no cv-qualifiers.");
            static constexpr int width = 4, height = 3;
            using type = T;
            using member_type = vec3<T>;
            union {member_type x, r, s;};
            union {member_type y, g, t;};
            union {member_type z, b, p;};
            union {member_type w, a, q;};
            constexpr vec() = default;
            explicit constexpr vec(member_type obj) : x(obj), y(obj), z(obj), w(obj) {}
            constexpr vec(member_type x, member_type y, member_type z, member_type w) : x(x), y(y), z(z), w(w) {}
            explicit constexpr vec(type obj) : x(obj), y(obj), z(obj), w(obj) {}
            constexpr vec(type xx, type yx, type zx, type wx, type xy, type yy, type zy, type wy, type xz, type yz, type zz, type wz) : x(xx,xy,xz), y(yx,yy,yz), z(zx,zy,zz), w(wx,wy,wz) {}
            template <typename TT> constexpr vec(const mat4x3<TT> &obj) : x(obj.x), y(obj.y), z(obj.z), w(obj.w) {}
            template <typename TT> [[nodiscard]] constexpr mat4x3<TT> to() const {return mat4x3<TT>(TT(x.x), TT(y.x), TT(z.x), TT(w.x), TT(x.y), TT(y.y), TT(z.y), TT(w.y), TT(x.z), TT(y.z), TT(z.z), TT(w.z));}
            static constexpr member_type vec::*pointers[width] {&vec::x, &vec::y, &vec::z, &vec::w};
            [[nodiscard]] constexpr member_type &operator[](int i) {return *this.*pointers[i];}
            [[nodiscard]] constexpr const member_type &operator[](int i) const {return *this.*pointers[i];}
            [[nodiscard]] type *as_array() {return &x.x;};
            [[nodiscard]] const type *as_array() const {return &x.x;};
            [[nodiscard]] explicit constexpr operator bool() const {return this->any(); static_assert(!std::is_same_v<type, bool>, "Use .none(), .any(), or .all() for vectors/matrices of bool.");}
            [[nodiscard]] constexpr bool none() const {return !this->any();}
            [[nodiscard]] constexpr bool any() const {return x.x || x.y || x.z || y.x || y.y || y.z || z.x || z.y || z.z || w.x || w.y || w.z;}
            [[nodiscard]] constexpr bool all() const {return x.x && x.y && x.z && y.x && y.y && y.z && z.x && z.y && z.z && w.x && w.y && w.z;}
            [[nodiscard]] constexpr type min() const {return std::min({x.x,x.y,x.z,y.x,y.y,y.z,z.x,z.y,z.z,w.x,w.y,w.z});}
            [[nodiscard]] constexpr type max() const {return std::max({x.x,x.y,x.z,y.x,y.y,y.z,z.x,z.y,z.z,w.x,w.y,w.z});}
        };
        
        template <typename T> struct vec<4,vec<4,T>> // mat4x4
        {
            static_assert(!std::is_const_v<T> && !std::is_volatile_v<T>, "The base type must have no cv-qualifiers.");
            static constexpr int width = 4, height = 4;
            static constexpr int size = 4;
            using type = T;
            using member_type = vec4<T>;
            union {member_type x, r, s;};
            union {member_type y, g, t;};
            union {member_type z, b, p;};
            union {member_type w, a, q;};
            constexpr vec() = default;
            explicit constexpr vec(member_type obj) : x(obj), y(obj), z(obj), w(obj) {}
            constexpr vec(member_type x, member_type y, member_type z, member_type w) : x(x), y(y), z(z), w(w) {}
            explicit constexpr vec(type obj) : x(obj), y(obj), z(obj), w(obj) {}
            constexpr vec(type xx, type yx, type zx, type wx, type xy, type yy, type zy, type wy, type xz, type yz, type zz, type wz, type xw, type yw, type zw, type ww) : x(xx,xy,xz,xw), y(yx,yy,yz,yw), z(zx,zy,zz,zw), w(wx,wy,wz,ww) {}
            template <typename TT> constexpr vec(const mat4x4<TT> &obj) : x(obj.x), y(obj.y), z(obj.z), w(obj.w) {}
            template <typename TT> [[nodiscard]] constexpr mat4x4<TT> to() const {return mat4x4<TT>(TT(x.x), TT(y.x), TT(z.x), TT(w.x), TT(x.y), TT(y.y), TT(z.y), TT(w.y), TT(x.z), TT(y.z), TT(z.z), TT(w.z), TT(x.w), TT(y.w), TT(z.w), TT(w.w));}
            static constexpr member_type vec::*pointers[width] {&vec::x, &vec::y, &vec::z, &vec::w};
            [[nodiscard]] constexpr member_type &operator[](int i) {return *this.*pointers[i];}
            [[nodiscard]] constexpr const member_type &operator[](int i) const {return *this.*pointers[i];}
            [[nodiscard]] type *as_array() {return &x.x;};
            [[nodiscard]] const type *as_array() const {return &x.x;};
            [[nodiscard]] explicit constexpr operator bool() const {return this->any(); static_assert(!std::is_same_v<type, bool>, "Use .none(), .any(), or .all() for vectors/matrices of bool.");}
            [[nodiscard]] constexpr bool none() const {return !this->any();}
            [[nodiscard]] constexpr bool any() const {return x.x || x.y || x.z || x.w || y.x || y.y || y.z || y.w || z.x || z.y || z.z || z.w || w.x || w.y || w.z || w.w;}
            [[nodiscard]] constexpr bool all() const {return x.x && x.y && x.z && x.w && y.x && y.y && y.z && y.w && z.x && z.y && z.z && z.w && w.x && w.y && w.z && w.w;}
            [[nodiscard]] constexpr type min() const {return std::min({x.x,x.y,x.z,x.w,y.x,y.y,y.z,y.w,z.x,z.y,z.z,z.w,w.x,w.y,w.z,w.w});}
            [[nodiscard]] constexpr type max() const {return std::max({x.x,x.y,x.z,x.w,y.x,y.y,y.z,y.w,z.x,z.y,z.z,z.w,w.x,w.y,w.z,w.w});}
        };
        //} Matrices
        
        //{ Operators
        //} Operators
    }
}
