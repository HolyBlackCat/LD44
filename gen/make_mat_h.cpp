#include <cstring>
#include <fstream>
#include <functional>
#include <iostream>
#include <string>
#include <sstream>
#include <type_traits>

#define VERSION "3.0.0 dev"

namespace data
{
    constexpr struct {const char *tag, *name;} type_list[]
    {
        "b",   "bool",
        "c",   "char",
        "uc",  "unsigned char",
        "sc",  "signed char",
        "s",   "short",
        "us",  "unsigned short",
        "i",   "int",
        "u",   "unsigned int",
        "l",   "long",
        "ul",  "unsigned long",
        "ll",  "long long",
        "ull", "unsigned long long",
        "f",   "float",
        "d",   "double",
        "ld",  "long double",
        "i8",  "int8_t",
        "u8",  "uint8_t",
        "i16", "int16_t",
        "u16", "uint16_t",
        "i32", "int32_t",
        "u32", "uint32_t",
        "i64", "int64_t",
        "u64", "uint64_t",
    };
    constexpr int type_list_len = std::extent_v<decltype(type_list)>;

    constexpr const char *fields[4] {"x","y","z","w"};
    constexpr int fields_alt_count = 3;
    constexpr const char *fields_alt[fields_alt_count][4]
    {
        fields[0], fields[1], fields[2], fields[3],
        "r","g","b","a",
        "s","t","p","q",
    };
}

namespace impl
{
    std::ofstream output_file("mat.h");

    std::stringstream ss;
    const std::stringstream::fmtflags stdfmt = ss.flags();

    bool at_line_start = 1;
    int indentation = 0;

    constexpr const char *indentation_string = "    ";
}

template <typename ...P> [[nodiscard]] std::string make_str(const P &... params)
{
    impl::ss.clear();
    impl::ss.str("");
    impl::ss.flags(impl::stdfmt);
    (impl::ss << ... << params);
    return impl::ss.str();
}

void output_str(const std::string &str)
{
    for (const char *ptr = str.c_str(); *ptr; ptr++)
    {
        char ch = *ptr;

        if ((ch == '}' || ch == ')') && impl::indentation > 0)
            impl::indentation--;

        if (impl::at_line_start)
        {
            if (std::strchr(" \t\r", ch))
                continue;

            for (int i = 0; i < impl::indentation; i++)
                impl::output_file << impl::indentation_string;
            impl::at_line_start = 0;
        }

        impl::output_file.put(ch);

        if (ch == '{' || ch == '(')
            impl::indentation++;

        if (ch == '\n')
            impl::at_line_start = 1;
    }
}

template <typename ...P> void output(const P &... params)
{
    output_str(make_str(params...));
}

void section(std::string header, std::function<void()> func)
{
    output(header, "\n{\n");
    func();
    output("}\n");
}
void section_sc(std::string header, std::function<void()> func) // 'sc' stands for 'end with semicolon'
{
    output(header, "\n{\n");
    func();
    output("};\n");
}

void decorative_section(std::string name, std::function<void()> func)
{
    output("//{ ", name, "\n");
    impl::indentation--;
    func();
    output("//} ", name, "\n");
    impl::indentation++;
}

void next_line()
{
    output("\n");
}

int main()
{
    if (!impl::output_file)
        return -1;

    { // Header
        output(1+R"(
            // mat.h
            // Vector and matrix math
            // Version )", VERSION, R"(
            // Autogenerated, don't touch.
        )");
        next_line();
    }

    { // Includes
        output(1+R"(
            #include <cstdint>
            #include <type_traits>
        )");
        next_line();
    }

    section("namespace Math", []
    {
        section("inline namespace Vector", []
        {
            decorative_section("Class declarations and aliases", []
            {
                { // Main templates
                    output(1+R"(
                        template <int D, typename T> struct vec;
                        template <int W, int H, typename T> using mat = vec<W, vec<H, T>>;
                    )");
                }

                { // Type-generic
                    // Vectors of specific size
                    for (int i = 2; i <= 4; i++)
                        output(" template <typename T> using vec", i, " = vec<", i, ",T>;");
                    next_line();

                    // Matrices of specific size
                    for (int h = 2; h <= 4; h++)
                    {
                        for (int w = 2; w <= 4; w++)
                            output(" template <typename T> using mat", w, "x", h, " = mat<", w, ",", h, ",T>;");
                        next_line();
                    }

                    // Square matrices of specific size
                    for (int i = 2; i <= 4; i++)
                        output(" template <typename T> using mat", i, " = mat", i, "x", i, "<T>;");
                    next_line();
                }
                next_line();

                { // For specific types
                    for (int i = 0; i < data::type_list_len; i++)
                    {
                        const auto &type = data::type_list[i];

                        // Any size
                        output("template <int D> using ", type.tag, "vec = vec<D,", type.name, ">;\n"
                               "template <int W, int H> using ", type.tag, "mat = mat<W,H,", type.name, ">;\n");

                        // Fixed size
                        for (int d = 2; d <= 4; d++)
                            output(" using ", type.tag, "vec", d, " = vec<", d, ',', type.name, ">;");
                        next_line();
                        for (int h = 2; h <= 4; h++)
                        {
                            for (int w = 2; w <= 4; w++)
                                output(" using ", type.tag, "mat", w, "x", h, " = mat<", w, ",", h, ",", type.name, ">;");
                            next_line();
                        }
                        for (int i = 2; i <= 4; i++)
                            output(" using ", type.tag, "mat", i, " = ", type.tag, "mat", i, "x", i, ";");
                        next_line();

                        if (i != data::type_list_len-1)
                            next_line();
                    }
                }
            });

            next_line();

            decorative_section("Class definitions", []
            {
                auto Make = [&](int w, int h)
                {
                    bool is_vector = (h == 0),
                         is_matrix = !is_vector;

                    std::string typeless_name, size_name;
                    if (is_vector)
                    {
                        typeless_name = make_str("vec", w);
                        size_name = "size";
                    }
                    else
                    {
                        typeless_name = make_str("mat", w, "x", h);
                        size_name = "width";
                    }


                    { // Static assertions
                        output("static_assert(!std::is_const_v<T> && !std::is_volatile_v<T>, \"The base type must have no cv-qualifiers.\");\n");
                    }

                    { // Dimensions
                        if (is_vector)
                            output("static constexpr int size = ", w, ";\n");
                        else
                        {
                            output("static constexpr int width = ", w, ", height = ", h, ";\n");
                            if (w == h)
                                output("static constexpr int size = ", w, ";\n");
                        }
                    }

                    { // Aliases
                        output("using type = T;\n");
                        if (is_vector)
                            output("using member_type = T;\n");
                        else
                            output("using member_type = vec", h, "<T>;\n");
                    }

                    { // Members
                        for (int i = 0; i < w; i++)
                        {
                            output("union {member_type ");
                            for (int j = 0; j < data::fields_alt_count; j++)
                            {
                                if (j != 0)
                                    output(", ");
                                output(data::fields_alt[j][i]);
                            }
                            output(";};\n");
                        }
                    }

                    { // Constructors
                        // Default
                        output("constexpr vec() = default;\n");

                        // Fill with a single value
                        output("explicit constexpr vec(member_type obj) : ");
                        for (int i = 0; i < w; i++)
                        {
                            if (i != 0)
                                output(", ");
                            output(data::fields[i], "(obj)");
                        }
                        output(" {}\n");

                        // Element-wise
                        output("constexpr vec(");
                        for (int i = 0; i < w; i++)
                        {
                            if (i != 0)
                                output(", ");
                            output("member_type ", data::fields[i]);
                        }
                        output(") : ");
                        for (int i = 0; i < w; i++)
                        {
                            if (i != 0)
                                output(", ");
                            output(data::fields[i], "(", data::fields[i], ")");
                        }
                        output(" {}\n");

                        // Matrix-specific constructors
                        if (is_matrix)
                        {
                            // Matrix fill with a single value
                            output("explicit constexpr vec(type obj) : ");
                            for (int i = 0; i < w; i++)
                            {
                                if (i != 0)
                                    output(", ");
                                output(data::fields[i], "(obj)");
                            }
                            output(" {}\n");

                            // Matrix element-wise
                            output("constexpr vec(");
                            for (int y = 0; y < h; y++)
                            for (int x = 0; x < w; x++)
                            {
                                if (x != 0 || y != 0)
                                    output(", ");
                                output("type ", data::fields[x], data::fields[y]);
                            }
                            output(") : ");
                            for (int x = 0; x < w; x++)
                            {
                                if (x != 0)
                                    output(", ");
                                output(data::fields[x], "(");
                                for (int y = 0; y < h; y++)
                                {
                                    if (y != 0)
                                        output(",");
                                    output(data::fields[x], data::fields[y]);
                                }
                                output(")");
                            }
                            output(" {}\n");
                        }

                        // Converting
                        output("template <typename TT> constexpr vec(const ", typeless_name, "<TT> &obj) : ");
                        for (int i = 0; i < w; i++)
                        {
                            if (i != 0)
                                output(", ");
                            output(data::fields[i], "(obj.", data::fields[i], ")");
                        }
                        output(" {}\n");
                    }

                    { // Convert to type
                        output("template <typename TT> [[nodiscard]] constexpr ", typeless_name, "<TT> to() const {return {");
                        if (is_vector)
                        {
                            for (int i = 0; i < w; i++)
                            {
                                if (i != 0)
                                    output(", ");
                                output("TT(", data::fields[i], ")");
                            }
                        }
                        else
                        {
                            for (int y = 0; y < h; y++)
                            for (int x = 0; x < w; x++)
                            {
                                if (x != 0 || y != 0)
                                    output(", ");
                                output("TT(", data::fields[x], ".", data::fields[y], ")");
                            }
                        }
                        output("};}\n");
                    }

                    { // Member access
                        // Member pointers array
                        output("static constexpr member_type vec::*pointers[", size_name, "] {");
                        for (int i = 0; i < w; i++)
                        {
                            if (i != 0)
                                output(", ");
                            output("&vec::", data::fields[i]);
                        }
                        output("};\n");

                        // Operator []
                        output("[[nodiscard]] constexpr member_type &operator[](int i) {return *this.*pointers[i];}\n");
                        output("[[nodiscard]] constexpr const member_type &operator[](int i) const {return *this.*pointers[i];}\n");

                        // As array
                        if (is_vector)
                        {
                            output("[[nodiscard]] type *as_array() {return &x;};\n");
                            output("[[nodiscard]] const type *as_array() const {return &x;};\n");
                        }
                        else
                        {
                            output("[[nodiscard]] type *as_array() {return &x.x;};\n");
                            output("[[nodiscard]] const type *as_array() const {return &x.x;};\n");
                        }




                        //
                    }
                };

                next_line();

                decorative_section("Vectors", [&]
                {
                    for (int d = 2; d <= 4; d++)
                    {
                        if (d != 2)
                            next_line();

                        section_sc(make_str("template <typename T> struct vec<", d, ",T> // vec", d), [&]{
                            Make(d, 0);
                        });
                    }
                });

                next_line();

                decorative_section("Matrices", [&]
                {
                    for (int w = 2; w <= 4; w++)
                    for (int h = 2; h <= 4; h++)
                    {
                        if (w != 2 || h != 2)
                            next_line();

                        section_sc(make_str("template <typename T> struct vec<", w, ",vec<", h, ",T>> // mat", w, "x", h), [&]{
                            Make(w, h);
                        });
                    }
                });

                next_line();
            });
        });


    });

    if (!impl::output_file)
        return -1;
}
